// @ts-check

// BEGIN (write your solution here)

export default class Node {
  constructor(key = null, left = null, right = null) {
    this.key = key;
    this.left = left;
    this.right = right;
  }

  getKey() {
    return this.key;
  }

  getLeft() {
    return this.left;
  }

  getRight() {
    return this.right;
  }

  search(key) {
    if (this.getKey() === key) {
      return this;
    }
    if (this.getKey() > key) {
      return this.getLeft()?.search(key) ?? null;
    }
    return this.getRight()?.search(key) ?? null;
  }

  insert(key) {
    if (this.getKey() === null) {
      this.key = key;
    }
    if (this.getKey() > key) {
      if (this.getLeft() === null) {
        this.left = new Node();
      }
      this.left.insert(key);
    }
    if (this.getKey() < key) {
      if (this.getRight() === null) {
        this.right = new Node();
      }
      this.right.insert(key);
    }
  }
}

// END
/* Node.js

// TASK #1

Двоичное дерево поиска состоит из узлов, каждый из которых содержит значение
ключа и два поддерева (левое и правое), которые в свою очередь также являются
двоичными деревьями. Правильное дерево не содержит повторяющихся ключей,
и для каждого узла гарантируется, что в левом поддереве все значения меньше текущего,
а в правом — больше.

Двоичное дерево поиска

Реализуйте и экспортируйте по умолчанию класс, который реализует представление узла.
Конструктор класса принимает на вход значение ключа (число), и двух детей, которые в
свою очередь также являются узлами. Дерево может быть создано пустым.

Класс должен содержать методы:

Геттер getKey() — возвращает ключ. Если дерево пустое, возвращает null.
Геттеры getLeft(), getRight() — возвращают соответственно левого и правого ребёнка.
Если ребёнок в узле отсутствует, геттер возвращает null.
search(key) — выполняет поиск узла в правильном двоичном дереве по ключу и возвращает узел.
Если узел не найден, возвращается null. */

// TASK #2

/* Двоичное дерево — иерархическая структура данных, в которой каждый узел имеет
не более двух потомков (детей). Как правило, первый называется родительским узлом,
а дети называются левым и правым наследниками.

В данном испытании мы будем использовать подвид двоичного дерева — двоичное дерево поиска.
Правильное дерево не содержит повторяющихся ключей, и для каждого узла гарантируется,
что в левом поддереве все значения меньше текущего, а в правом — больше.

Двоичное дерево поиска

Node.js
Реализуйте и экспортируйте по умолчанию класс, который реализует представление узла.

Класс должен содержать:

Геттер getKey() — возвращает ключ.
Геттеры getLeft(), getRight() — возвращают соответственно левого и правого ребёнка.
Если ребёнок в узле отсутствует, геттер возвращает null.
Метод insert(key) — выполняет добавление узла, формируя правильное двоичное дерево.
Примеры
const tree = new Node();
tree.insert(9);
tree.insert(17);
tree.insert(4);
tree.insert(3);
tree.insert(6);

tree.getKey(); // 9
tree.getLeft().getKey(); // 4
tree.getRight().getKey(); // 17
tree.getLeft().getLeft().getKey(); // 3
tree.getLeft().getRight().getKey(); // 6 */
